@page "/verification"
@using SpawnDev.BlazorJS.PixiJS
@using static SpawnDev.BlazorJS.PixiJS.PIXI
@using SpawnDev.BlazorJS.JsonConverters
@using SpawnDev.BlazorJS.JSObjects
@using System.Threading.Tasks
@implements IDisposable

<h3>Wrapper Verification</h3>
<div @ref="containerElRef" style="width: 800px; height: 600px;"></div>

@code {
    [Inject] BlazorJSRuntime JS { get; set; }
    ElementReference? containerElRef;
    Application? app;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Init();
        }
    }

    async Task Init()
    {
        app = new Application();
        await app.Init(new ApplicationOptions { Background = "#1099bb", ResizeTo = containerElRef });
        using var htmlElement = new HTMLElement(containerElRef!.Value);
        htmlElement!.AppendChild(app.Canvas);

        // Test Application.Renderer
        var renderer = app.Renderer;
        JS.Log("Renderer found:", renderer);

        // Test Graphics Stroke(ColorSource)
        using var graphics = new Graphics();
        graphics.Rect(50, 50, 100, 100);
        graphics.Fill(0xFF0000);
        graphics.Stroke(0xFFFFFF); // Test overload
        app.Stage!.AddChild(graphics);

        // Test Sprite Anchor & Texture properties
        using var texture = await PIXI.Assets.Load<Texture>("https://pixijs.com/assets/bunny.png");
        var sprite = new Sprite(texture);
        sprite.Anchor.Set(0.5f); // Anchor property
        sprite.X = 300;
        sprite.Y = 300;
        sprite.Scale.Set(3);
        sprite.Texture = texture; // Texture property setter check
        
        // Test Container props
        sprite.Cursor = "pointer";
        sprite.EventMode = "static";
        sprite.ZIndex = 10;
        
        app.Stage.AddChild(sprite);

        sprite.On("pointerdown", () => 
        {
            JS.Log("Sprite clicked!");
            sprite.Alpha = sprite.Alpha == 1 ? 0.5f : 1f;
        });


        // Test Container Methods
        var container = new Container();
        container.X = 100;
        container.Y = 400;
        app.Stage.AddChild(container);
        
        var child1 = new Graphics();
        child1.Rect(0,0,50,50).Fill(0x00FF00);
        container.AddChild(child1);
        
        var child2 = new Graphics();
        child2.Rect(60,0,50,50).Fill(0x0000FF);
        container.AddChild(child2);
        
        // Swap
        container.SwapChildren(child1, child2);
        
        // GetChildAt
        var c1 = container.GetChildAt(0);
        JS.Log("Child at 0 is child2 (blue)?", c1.Equals(child2)); // Should be true after swap if they were 0 and 1

        // Phase 2: Text & Texture Verification
        var style = new PIXI.TextStyle { FontSize = 36, Fill = "white", Stroke = "red", DropShadow = new TextDropShadow { Alpha = 0.5f, Angle = 0.5f, Blur = 2, Color = "#111111", Distance = 10 } };
        var text = new PIXI.Text("Hello Blazor!", style);
        text.X = 400;
        text.Y = 100;
        app.Stage.AddChild(text);

        // Texture.From
        var textureFrom = Texture.From("https://pixijs.com/assets/bunny.png");
        var spriteFrom = new Sprite(textureFrom);
        spriteFrom.X = 500;
        spriteFrom.Y = 100;
        app.Stage.AddChild(spriteFrom);
        JS.Log("Texture dimensions:", textureFrom.Width, textureFrom.Height);

        // Phase 3: TilingSprite & Filters
        var tilingSprite = new TilingSprite(textureFrom, 200, 100);
        tilingSprite.X = 100;
        tilingSprite.Y = 500;
        tilingSprite.TileScale.Set(0.5f);
        app.Stage.AddChild(tilingSprite);

        // Apply BlurFilter to TilingSprite
        var blurFilter = new BlurFilter(5);
        tilingSprite.Filters = new Filter[] { blurFilter };

        // Test AnimatedSprite
        // Load a second texture to make animation visible
        using var texture2 = await PIXI.Assets.Load<Texture>("https://pixijs.com/assets/flowerTop.png");
        var textures = new Texture[] { textureFrom, texture2 };
        var animSprite = new AnimatedSprite(textures);
        animSprite.X = 400;
        animSprite.Y = 500;
        animSprite.AnimationSpeed = 0.1f;
        animSprite.Play();
        app.Stage.AddChild(animSprite);
        JS.Log("AnimatedSprite playing:", animSprite.Playing);

        // Phase 4: NineSliceSprite, HTMLText, Mesh, Filters, Events
        
        // NineSliceSprite
        var nineSlice = new NineSliceSprite(textureFrom, 10, 10, 10, 10);
        nineSlice.Width = 150;
        nineSlice.Height = 80;
        nineSlice.X = 50;
        nineSlice.Y = 200;
        app.Stage.AddChild(nineSlice);

        // HTMLText
        var htmlStyle = new HTMLTextStyle { Fill = "cyan", FontSize = 24 };
        var htmlText = new HTMLText("<strong>HTML</strong> Text!", htmlStyle);
        htmlText.X = 250;
        htmlText.Y = 200;
        app.Stage.AddChild(htmlText);

        // MeshPlane (Perspective)
        var meshPlane = new MeshPlane(textureFrom, 4, 4);
        meshPlane.X = 550;
        meshPlane.Y = 200;
        app.Stage.AddChild(meshPlane);
        
        // ColorMatrixFilter (Grayscale)
        var colorMatrix = new ColorMatrixFilter();
        meshPlane.Filters = new Filter[] { colorMatrix };
        colorMatrix.Greyscale(0.5f, false);
        
        // Events: Click listener using FederatedPointerEvent
        nineSlice.EventMode = "static";
        nineSlice.Cursor = "pointer";
        nineSlice.On<FederatedPointerEvent>("pointerdown", (e) => {
            JS.Log("NineSlice clicked at global:", e.Global.X, e.Global.Y);
            nineSlice.Alpha = 0.5f;
        });

        // Phase 6: RenderTexture, MaskData, BitmapText, Ticker
        
        // RenderTexture
        var renderTexture = RenderTexture.Create(new RenderTextureOptions { Width = 100, Height = 100 });
        var rtSprite = new Sprite(renderTexture);
        rtSprite.X = 650;
        rtSprite.Y = 50;
        app.Stage.AddChild(rtSprite);
        
        // Render the existing bunny sprite to the texture
        app.Renderer.Render(sprite, new RenderOptions { RenderTexture = renderTexture });
        
        // MaskData
        var maskGraphics = new Graphics();
        maskGraphics.Rect(0, 0, 100, 100).Fill(0xFFFFFF);
        var maskedContainer = new Container();
        maskedContainer.X = 100;
        maskedContainer.Y = 100;
        maskedContainer.AddChild(maskGraphics); // Add mask to display hierarchy (optional but good for testing)
        // maskedContainer.Mask = maskGraphics; // Simple mask assignment - commented out to test MaskData if strictly needed, but MaskData is usually internal. 
        // Let's test Mask property directly with Graphics as it's the common use case, MaskData is the underlying structure.
        
        // BitmapText
        // Note: BitmapText requires a pre-loaded bitmap font. Using standard Text for now as backup if font loading is complex in this demo, 
        // but verifying the class instantiation works.
        try {
            var bitmapText = new BitmapText("Bitmap Text", new BitmapTextOptions { 
                Style = new PIXI.TextStyle { FontSize = 20, Fill = "yellow" } 
            });
            bitmapText.X = 650;
            bitmapText.Y = 400;
            app.Stage.AddChild(bitmapText);
        } catch (Exception ex) {
            JS.Log("BitmapText creation (expected failure if font missing):", ex.Message);
        }

        // Ticker
        JS.Log("Ticker Shared FPS:", Ticker.Shared.FPS);
        // Phase 7: Math Shapes and Geometry

        // Math Shapes - Draw them using Graphics
        var shapesGraphics = new Graphics();
        
        // Circle
        shapesGraphics.Circle(650, 500, 30).Fill("red");
        
        // Ellipse
        shapesGraphics.Ellipse(750, 500, 50, 30).Fill("green");
        
        // RoundedRectangle
        shapesGraphics.RoundRect(850, 480, 60, 40, 10).Fill("blue");
        
        // Polygon
        shapesGraphics.Poly(new float[] { 950, 500, 970, 480, 990, 500 }).Fill("purple");
        
        app.Stage.AddChild(shapesGraphics);

        // Geometry and Mesh
        // Create a simple quad geometry
        var geometry = new Geometry();
        geometry.AddAttribute("aPosition", new PIXI.Buffer(new float[] 
        {
            -50, -50, // x, y
             50, -50,
             50,  50,
            -50,  50
        }), 2);
        geometry.AddAttribute("aUV", new PIXI.Buffer(new float[]
        {
            0, 0, // u, v
            1, 0,
            1, 1,
            0, 1
        }), 2);
        
        // geometry.AddIndex([0, 1, 2, 0, 2, 3]); // Pixi usually infers indices from draw order if missing or we can add them
        geometry.AddIndex(new PIXI.Buffer(new int[] { 0, 1, 2, 0, 2, 3 }));

        // Use the existing bunny texture for the mesh
        // Note: Mesh requires a specific shader usually, but we can try MeshSimple (if compatible) or just verify Geometry instantiation.
        // MeshSimple overrides geometry locally usually. 
        // Let's just log create success to verify the wrappers work without crashing 
        // as creating a full custom shader/mesh setup is advanced for a basic verification test.
        JS.Log("Custom Geometry created with attributes and index buffer.");
        
        // However, we can create a Mesh with it if we had a proper shader. 
        // For now, let's just confirm it doesn't throw.
        // customMesh...

        // Phase 8: Advanced Text & Interaction
        
        // HTMLText with simple styling
        // Note: HTMLText uses DOM so standard styles apply
        var htmlTextAdvanced = new HTMLText(new HTMLTextOptions 
        { 
            Text = "HTML Text",
            Style = new HTMLTextStyleOptions 
            { 
                FontSize = 30,
                Fill = "white",
                Align = "center"
            }
        });
        htmlTextAdvanced.X = 650;
        htmlTextAdvanced.Y = 550;
        app.Stage.AddChild(htmlTextAdvanced);
        
        // Event System Check
        JS.Log("Event System Cursor:", app.Renderer.Events.Cursor);
        
        // Interaction Check
        htmlTextAdvanced.EventMode = "static";
        htmlTextAdvanced.Cursor = "pointer";
        htmlTextAdvanced.On("pointerdown", (FederatedPointerEvent e) => 
        {
            JS.Log("HTMLText clicked!");
            htmlTextAdvanced.Alpha = 0.5f;
        });

    }

    public void Dispose()
    {
        app?.Dispose();
    }
}
